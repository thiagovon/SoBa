LAB4

1)
150 = 1001 0110
	0x96

-3 = 0000 0000 0000 0011
	Converter
     1111 1111 1111 1100
		      		  +1
     1111 1111 1111 1101
	0xFFFD
			

-151 =  0000 0000 0000 0000 0000 0000 1001 0111
			Converter
	1111 1111 1111 1111 1111 1111 0110 1000
					     				 +1
	1111 1111 1111 1111 1111 1111 0110 1001
			0xFFFFFF69

2) 
-32765 = 0111 1111 1111 1101
	 1000 0000 0000 0010
			  		  +1
	 1000 0000 0000 0011
	   8	0    0    3

32771 =  1000 0000 0000 0011
	   8    0    0    3

Podemos chegar a conclusão que, um valor numérico na memória é apenas uma sequência de bits. O que de fato dá significado a essa sequência é o tipo de dado da variável (nesse caso signed e unsigned), assim dizendo ao programa como interpretar esses bits.
	  	 		
3) 
int xbyte (packed_t word, int bytenum) {
    unsigned char palavra_movida = word >> (bytenum * 8);
    unsigned char byte_isolado = palavra_movida & 0xff;
    return (int) ((char) byte_isolado);
}

4)No primeiro caso, as variáveis são do tipo int (com sinal). Então, o padrão de bits 0xffffffff é interpretado como o valor -1. A comparação é (-1 < 2), que é verdadeira.

Já no segundo caso, as variáveis são do tipo unsigned int (sem sinal). O mesmo padrão de bits 0xffffffff é interpretado como o valor positivo máximo para um inteiro de 32 bits, que é 4.294.967.295. A comparação se torna (4.294.967.295 < 2), que é falsa.

No terceiro caso, programa compara um int com valor -1 e um unsigned int com valor 2.
Para resolver a comparação, o C converte o -1 para um unsigned int de 32 bits, que é o valor 4.294.967.295. A condição avaliada pelo computador se torna (4.294.967.295 < 2), que é falsa.
A regra de promoção de tipo explica por que o resultado é "nao", mesmo que o printf mostre o valor -1


5) A saída do dump de ui mostrará que todos os 4 bytes estão preenchidos com 0xff, confirmando que a extensão de sinal ocorreu corretamente. O valor impresso por printf com %u será 4294967295, que é a interpretação sem sinal do padrão de bits 0xffffffff.